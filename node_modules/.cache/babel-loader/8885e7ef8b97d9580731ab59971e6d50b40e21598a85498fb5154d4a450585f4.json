{"ast":null,"code":"import { lineString } from \"@turf/helpers\";\nimport { compactNode } from \"./compactor\";\nimport findPath from \"./dijkstra\";\nimport preprocess from \"./preprocessor\";\nimport roundCoord from \"./round-coord\";\nimport { defaultKey } from \"./topology\";\nexport default class PathFinder {\n  constructor(network) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.graph = preprocess(network, options);\n    this.options = options;\n    // if (\n    //   Object.keys(this.graph.compactedVertices).filter(function (k) {\n    //     return k !== \"edgeData\";\n    //   }).length === 0\n    // ) {\n    //   throw new Error(\n    //     \"Compacted graph contains no forks (topology has no intersections).\"\n    //   );\n    // }\n  }\n\n  findPath(a, b) {\n    const {\n      key = defaultKey,\n      tolerance = 1e-5\n    } = this.options;\n    const start = key(roundCoord(a.geometry.coordinates, tolerance));\n    const finish = key(roundCoord(b.geometry.coordinates, tolerance));\n    // We can't find a path if start or finish isn't in the\n    // set of non-compacted vertices\n    if (!this.graph.vertices[start] || !this.graph.vertices[finish]) {\n      return undefined;\n    }\n    const phantomStart = this._createPhantom(start);\n    const phantomEnd = this._createPhantom(finish);\n    try {\n      const pathResult = findPath(this.graph.compactedVertices, start, finish);\n      if (pathResult) {\n        const [weight, path] = pathResult;\n        return {\n          path: path.reduce((coordinates, vertexKey, index, vertexKeys) => {\n            if (index > 0) {\n              coordinates = coordinates.concat(this.graph.compactedCoordinates[vertexKeys[index - 1]][vertexKey]);\n            }\n            return coordinates;\n          }, []).concat([this.graph.sourceCoordinates[finish]]),\n          weight,\n          edgeDatas: this.graph.compactedEdges ? path.reduce((edges, vertexKey, index, vertexKeys) => {\n            if (index > 0) {\n              edges.push(this.graph.compactedEdges[vertexKeys[index - 1]][vertexKey]);\n            }\n            return edges;\n          }, []) : undefined\n        };\n      } else {\n        return undefined;\n      }\n    } finally {\n      this._removePhantom(phantomStart);\n      this._removePhantom(phantomEnd);\n    }\n  }\n  _createPhantom(n) {\n    if (this.graph.compactedVertices[n]) return undefined;\n    const phantom = compactNode(n, this.graph.vertices, this.graph.compactedVertices, this.graph.sourceCoordinates, this.graph.edgeData, true, this.options);\n    this.graph.compactedVertices[n] = phantom.edges;\n    this.graph.compactedCoordinates[n] = phantom.coordinates;\n    if (this.graph.compactedEdges) {\n      this.graph.compactedEdges[n] = phantom.reducedEdges;\n    }\n    Object.keys(phantom.incomingEdges).forEach(neighbor => {\n      this.graph.compactedVertices[neighbor][n] = phantom.incomingEdges[neighbor];\n      if (!this.graph.compactedCoordinates[neighbor]) {\n        this.graph.compactedCoordinates[neighbor] = {};\n      }\n      this.graph.compactedCoordinates[neighbor][n] = [this.graph.sourceCoordinates[neighbor], ...phantom.incomingCoordinates[neighbor].slice(0, -1)];\n      if (this.graph.compactedEdges) {\n        if (!this.graph.compactedEdges[neighbor]) {\n          this.graph.compactedEdges[neighbor] = {};\n        }\n        this.graph.compactedEdges[neighbor][n] = phantom.reducedEdges[neighbor];\n      }\n    });\n    return n;\n  }\n  _removePhantom(n) {\n    if (!n) return;\n    Object.keys(this.graph.compactedVertices[n]).forEach(neighbor => {\n      delete this.graph.compactedVertices[neighbor][n];\n    });\n    Object.keys(this.graph.compactedCoordinates[n]).forEach(neighbor => {\n      delete this.graph.compactedCoordinates[neighbor][n];\n    });\n    if (this.graph.compactedEdges) {\n      Object.keys(this.graph.compactedEdges[n]).forEach(neighbor => {\n        delete this.graph.compactedEdges[neighbor][n];\n      });\n    }\n    delete this.graph.compactedVertices[n];\n    delete this.graph.compactedCoordinates[n];\n    if (this.graph.compactedEdges) {\n      delete this.graph.compactedEdges[n];\n    }\n  }\n}\nexport function pathToGeoJSON(path) {\n  if (path) {\n    const {\n      weight,\n      edgeDatas\n    } = path;\n    return lineString(path.path, {\n      weight,\n      edgeDatas\n    });\n  }\n}","map":{"version":3,"names":["lineString","compactNode","findPath","preprocess","roundCoord","defaultKey","PathFinder","constructor","network","options","arguments","length","undefined","graph","a","b","key","tolerance","start","geometry","coordinates","finish","vertices","phantomStart","_createPhantom","phantomEnd","pathResult","compactedVertices","weight","path","reduce","vertexKey","index","vertexKeys","concat","compactedCoordinates","sourceCoordinates","edgeDatas","compactedEdges","edges","push","_removePhantom","n","phantom","edgeData","reducedEdges","Object","keys","incomingEdges","forEach","neighbor","incomingCoordinates","slice","pathToGeoJSON"],"sources":["/Users/valu/Desktop/TESTSDS/Systems-DS-Grab-Simulation/node_modules/geojson-path-finder/src/index.ts"],"sourcesContent":["import {\n  Feature,\n  FeatureCollection,\n  lineString,\n  LineString,\n  Point,\n  Position,\n} from \"@turf/helpers\";\nimport { compactNode } from \"./compactor\";\nimport findPath from \"./dijkstra\";\nimport preprocess from \"./preprocessor\";\nimport roundCoord from \"./round-coord\";\nimport { defaultKey } from \"./topology\";\nimport { Key, Path, PathFinderGraph, PathFinderOptions } from \"./types\";\n\nexport default class PathFinder<TEdgeReduce, TProperties> {\n  graph: PathFinderGraph<TEdgeReduce>;\n  options: PathFinderOptions<TEdgeReduce, TProperties>;\n\n  constructor(\n    network: FeatureCollection<LineString, TProperties>,\n    options: PathFinderOptions<TEdgeReduce, TProperties> = {}\n  ) {\n    this.graph = preprocess(network, options);\n    this.options = options;\n\n    // if (\n    //   Object.keys(this.graph.compactedVertices).filter(function (k) {\n    //     return k !== \"edgeData\";\n    //   }).length === 0\n    // ) {\n    //   throw new Error(\n    //     \"Compacted graph contains no forks (topology has no intersections).\"\n    //   );\n    // }\n  }\n\n  findPath(\n    a: Feature<Point>,\n    b: Feature<Point>\n  ): Path<TEdgeReduce> | undefined {\n    const { key = defaultKey, tolerance = 1e-5 } = this.options;\n    const start = key(roundCoord(a.geometry.coordinates, tolerance));\n    const finish = key(roundCoord(b.geometry.coordinates, tolerance));\n\n    // We can't find a path if start or finish isn't in the\n    // set of non-compacted vertices\n    if (!this.graph.vertices[start] || !this.graph.vertices[finish]) {\n      return undefined;\n    }\n\n    const phantomStart = this._createPhantom(start);\n    const phantomEnd = this._createPhantom(finish);\n    try {\n      const pathResult = findPath(this.graph.compactedVertices, start, finish);\n\n      if (pathResult) {\n        const [weight, path] = pathResult;\n        return {\n          path: path\n            .reduce(\n              (\n                coordinates: Position[],\n                vertexKey: Key,\n                index: number,\n                vertexKeys: Key[]\n              ) => {\n                if (index > 0) {\n                  coordinates = coordinates.concat(\n                    this.graph.compactedCoordinates[vertexKeys[index - 1]][\n                      vertexKey\n                    ]\n                  );\n                }\n\n                return coordinates;\n              },\n              []\n            )\n            .concat([this.graph.sourceCoordinates[finish]]),\n          weight,\n          edgeDatas: this.graph.compactedEdges\n            ? path.reduce(\n                (\n                  edges: (TEdgeReduce | undefined)[],\n                  vertexKey: Key,\n                  index: number,\n                  vertexKeys: Key[]\n                ) => {\n                  if (index > 0) {\n                    edges.push(\n                      this.graph.compactedEdges[vertexKeys[index - 1]][\n                        vertexKey\n                      ]\n                    );\n                  }\n\n                  return edges;\n                },\n                []\n              )\n            : undefined,\n        };\n      } else {\n        return undefined;\n      }\n    } finally {\n      this._removePhantom(phantomStart);\n      this._removePhantom(phantomEnd);\n    }\n  }\n\n  _createPhantom(n: Key) {\n    if (this.graph.compactedVertices[n]) return undefined;\n\n    const phantom = compactNode(\n      n,\n      this.graph.vertices,\n      this.graph.compactedVertices,\n      this.graph.sourceCoordinates,\n      this.graph.edgeData,\n      true,\n      this.options\n    );\n    this.graph.compactedVertices[n] = phantom.edges;\n    this.graph.compactedCoordinates[n] = phantom.coordinates;\n\n    if (this.graph.compactedEdges) {\n      this.graph.compactedEdges[n] = phantom.reducedEdges;\n    }\n\n    Object.keys(phantom.incomingEdges).forEach((neighbor) => {\n      this.graph.compactedVertices[neighbor][n] =\n        phantom.incomingEdges[neighbor];\n      if (!this.graph.compactedCoordinates[neighbor]) {\n        this.graph.compactedCoordinates[neighbor] = {};\n      }\n      this.graph.compactedCoordinates[neighbor][n] = [\n        this.graph.sourceCoordinates[neighbor],\n        ...phantom.incomingCoordinates[neighbor].slice(0, -1),\n      ];\n      if (this.graph.compactedEdges) {\n        if (!this.graph.compactedEdges[neighbor]) {\n          this.graph.compactedEdges[neighbor] = {};\n        }\n        this.graph.compactedEdges[neighbor][n] = phantom.reducedEdges[neighbor];\n      }\n    });\n\n    return n;\n  }\n\n  _removePhantom(n: Key | undefined) {\n    if (!n) return;\n\n    Object.keys(this.graph.compactedVertices[n]).forEach((neighbor) => {\n      delete this.graph.compactedVertices[neighbor][n];\n    });\n    Object.keys(this.graph.compactedCoordinates[n]).forEach((neighbor) => {\n      delete this.graph.compactedCoordinates[neighbor][n];\n    });\n    if (this.graph.compactedEdges) {\n      Object.keys(this.graph.compactedEdges[n]).forEach((neighbor) => {\n        delete this.graph.compactedEdges[neighbor][n];\n      });\n    }\n\n    delete this.graph.compactedVertices[n];\n    delete this.graph.compactedCoordinates[n];\n\n    if (this.graph.compactedEdges) {\n      delete this.graph.compactedEdges[n];\n    }\n  }\n}\n\nexport function pathToGeoJSON<TEdgeReduce>(\n  path: Path<TEdgeReduce> | undefined\n):\n  | Feature<\n      LineString,\n      { weight: number; edgeDatas: (TEdgeReduce | undefined)[] | undefined }\n    >\n  | undefined {\n  if (path) {\n    const { weight, edgeDatas } = path;\n    return lineString(path.path, { weight, edgeDatas });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}