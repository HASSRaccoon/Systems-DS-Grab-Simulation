{"ast":null,"code":"/**\n * Given a graph of vertices and edges, simplifies the graph so redundant\n * nodes/edges are removed, only preserving nodes which are either:\n *\n *   * Dead ends: end of lines, where you can only go back in the opposite\n *     direction\n *   * Forks, where there is an option to go in multiple directions\n *\n * The idea is to reduce the number of nodes in the graph, which drasticly\n * reduces the complexity of Dijkstra's algorithm.\n *\n * @param vertices the graph's vertices (a lookup of vertex edges and weights)\n * @param vertexCoords the geographic coordinates of the vertices\n * @param edgeData the (optional) data associated with each edge\n * @param options options used for creating and compacting the graph\n * @returns\n */\nexport default function compactGraph(vertices, vertexCoords, edgeData) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    progress,\n    compact = true\n  } = options;\n  const ends = Object.keys(vertices).reduce(findForks, {});\n  return Object.keys(ends).reduce(compactFork, {\n    graph: {},\n    coordinates: {},\n    reducedEdges: {}\n  });\n  function findForks(ends, key, index, vertexKeys) {\n    const vertex = vertices[key];\n    const edges = Object.keys(vertex);\n    const numberEdges = edges.length;\n    let isEnd;\n    if (!compact) {\n      // If instructed not to compact, everything is treated as a fork\n      // (can't be compacted)\n      isEnd = true;\n    } else if (numberEdges === 1) {\n      // A vertex with a single edge A->B is a fork\n      // if B has an edge to A.\n      // (It's a fork in the sense that it is a dead end and you can only turn back to B.)\n      const other = vertices[edges[0]];\n      isEnd = other[key];\n    } else if (numberEdges === 2) {\n      // A vertex A which lies between two vertices B and C (only has two edges)\n      // is only a fork if you can't go back to A from at least one of them.\n      isEnd = edges.some(n => !vertices[n][key]);\n    } else {\n      // A vertex with more than two edges (a fork) is always a fork\n      isEnd = true;\n    }\n    if (isEnd) {\n      ends[key] = vertex;\n    }\n    if (index % 1000 === 0 && progress) {\n      progress(\"compact:ends\", index, vertexKeys.length);\n    }\n    return ends;\n  }\n  function compactFork(result, key, index, forks) {\n    var compacted = compactNode(key, vertices, ends, vertexCoords, edgeData, false, options);\n    result.graph[key] = compacted.edges;\n    result.coordinates[key] = compacted.coordinates;\n    result.reducedEdges[key] = compacted.reducedEdges;\n    if (index % 1000 === 0 && progress) {\n      progress(\"compact:nodes\", index, forks.length);\n    }\n    return result;\n  }\n}\nexport function compactNode(key, vertices, ends, vertexCoords, edgeData, trackIncoming) {\n  let options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n  const neighbors = vertices[key];\n  return Object.keys(neighbors).reduce(compactEdge, {\n    edges: {},\n    incomingEdges: {},\n    coordinates: {},\n    incomingCoordinates: {},\n    reducedEdges: {}\n  });\n  function compactEdge(result, j) {\n    const neighbor = findNextFork(key, j, vertices, ends, vertexCoords, edgeData, trackIncoming, options);\n    const weight = neighbor.weight;\n    const reverseWeight = neighbor.reverseWeight;\n    if (neighbor.vertexKey !== key) {\n      if (!result.edges[neighbor.vertexKey] || result.edges[neighbor.vertexKey] > weight) {\n        result.edges[neighbor.vertexKey] = weight;\n        result.coordinates[neighbor.vertexKey] = [vertexCoords[key]].concat(neighbor.coordinates);\n        result.reducedEdges[neighbor.vertexKey] = neighbor.reducedEdge;\n      }\n      if (trackIncoming && !isNaN(reverseWeight) && (!result.incomingEdges[neighbor.vertexKey] || result.incomingEdges[neighbor.vertexKey] > reverseWeight)) {\n        result.incomingEdges[neighbor.vertexKey] = reverseWeight;\n        var coordinates = [vertexCoords[key]].concat(neighbor.coordinates);\n        coordinates.reverse();\n        result.incomingCoordinates[neighbor.vertexKey] = coordinates;\n      }\n    }\n    return result;\n  }\n}\nfunction findNextFork(prev, vertexKey, vertices, ends, vertexCoords, edgeData, trackIncoming) {\n  let options = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  let weight = vertices[prev][vertexKey];\n  let reverseWeight = vertices[vertexKey][prev];\n  const coordinates = [];\n  const path = [];\n  let reducedEdge = \"edgeDataReducer\" in options ? edgeData[vertexKey][prev] : undefined;\n  while (!ends[vertexKey]) {\n    var edges = vertices[vertexKey];\n    if (!edges) {\n      break;\n    }\n    var next = Object.keys(edges).filter(function notPrevious(k) {\n      return k !== prev;\n    })[0];\n    weight += edges[next];\n    if (trackIncoming) {\n      reverseWeight += vertices[next][vertexKey];\n      if (path.indexOf(vertexKey) >= 0) {\n        ends[vertexKey] = vertices[vertexKey];\n        break;\n      }\n      path.push(vertexKey);\n    }\n    const nextEdgeData = edgeData[vertexKey] && edgeData[vertexKey][next];\n    if (\"edgeDataReducer\" in options && reducedEdge && nextEdgeData) {\n      reducedEdge = options.edgeDataReducer(reducedEdge, nextEdgeData);\n    }\n    coordinates.push(vertexCoords[vertexKey]);\n    prev = vertexKey;\n    vertexKey = next;\n  }\n  return {\n    vertexKey,\n    weight: weight,\n    reverseWeight: reverseWeight,\n    coordinates: coordinates,\n    reducedEdge: reducedEdge\n  };\n}","map":{"version":3,"names":["compactGraph","vertices","vertexCoords","edgeData","options","arguments","length","undefined","progress","compact","ends","Object","keys","reduce","findForks","compactFork","graph","coordinates","reducedEdges","key","index","vertexKeys","vertex","edges","numberEdges","isEnd","other","some","n","result","forks","compacted","compactNode","trackIncoming","neighbors","compactEdge","incomingEdges","incomingCoordinates","j","neighbor","findNextFork","weight","reverseWeight","vertexKey","concat","reducedEdge","isNaN","reverse","prev","path","next","filter","notPrevious","k","indexOf","push","nextEdgeData","edgeDataReducer"],"sources":["/Users/valu/Desktop/TESTSDS/Systems-DS-Grab-Simulation/node_modules/geojson-path-finder/src/compactor.ts"],"sourcesContent":["import { Position } from \"@turf/helpers\";\nimport { Coordinates, PathFinderOptions, Vertices, Key } from \"./types\";\n\n/**\n * Given a graph of vertices and edges, simplifies the graph so redundant\n * nodes/edges are removed, only preserving nodes which are either:\n *\n *   * Dead ends: end of lines, where you can only go back in the opposite\n *     direction\n *   * Forks, where there is an option to go in multiple directions\n *\n * The idea is to reduce the number of nodes in the graph, which drasticly\n * reduces the complexity of Dijkstra's algorithm.\n *\n * @param vertices the graph's vertices (a lookup of vertex edges and weights)\n * @param vertexCoords the geographic coordinates of the vertices\n * @param edgeData the (optional) data associated with each edge\n * @param options options used for creating and compacting the graph\n * @returns\n */\nexport default function compactGraph<TEdgeData, TProperties>(\n  vertices: Vertices,\n  vertexCoords: Coordinates,\n  edgeData: Record<Key, Record<Key, TEdgeData | undefined>>,\n  options: PathFinderOptions<TEdgeData, TProperties> = {}\n) {\n  const { progress, compact = true } = options;\n  const ends = Object.keys(vertices).reduce(findForks, {});\n\n  return Object.keys(ends).reduce(compactFork, {\n    graph: {},\n    coordinates: {},\n    reducedEdges: {},\n  });\n\n  function findForks(\n    ends: Vertices,\n    key: Key,\n    index: number,\n    vertexKeys: Key[]\n  ): Vertices {\n    const vertex = vertices[key];\n    const edges = Object.keys(vertex);\n    const numberEdges = edges.length;\n    let isEnd;\n\n    if (!compact) {\n      // If instructed not to compact, everything is treated as a fork\n      // (can't be compacted)\n      isEnd = true;\n    } else if (numberEdges === 1) {\n      // A vertex with a single edge A->B is a fork\n      // if B has an edge to A.\n      // (It's a fork in the sense that it is a dead end and you can only turn back to B.)\n      const other = vertices[edges[0]];\n      isEnd = other[key];\n    } else if (numberEdges === 2) {\n      // A vertex A which lies between two vertices B and C (only has two edges)\n      // is only a fork if you can't go back to A from at least one of them.\n      isEnd = edges.some((n) => !vertices[n][key]);\n    } else {\n      // A vertex with more than two edges (a fork) is always a fork\n      isEnd = true;\n    }\n\n    if (isEnd) {\n      ends[key] = vertex;\n    }\n\n    if (index % 1000 === 0 && progress) {\n      progress(\"compact:ends\", index, vertexKeys.length);\n    }\n\n    return ends;\n  }\n\n  function compactFork(\n    result: {\n      graph: Vertices;\n      coordinates: Record<Key, Record<Key, Position[]>>;\n      reducedEdges: Record<Key, Record<Key, TEdgeData | undefined>>;\n    },\n    key: Key,\n    index: number,\n    forks: Key[]\n  ) {\n    var compacted = compactNode(\n      key,\n      vertices,\n      ends,\n      vertexCoords,\n      edgeData,\n      false,\n      options\n    );\n    result.graph[key] = compacted.edges;\n    result.coordinates[key] = compacted.coordinates;\n    result.reducedEdges[key] = compacted.reducedEdges;\n\n    if (index % 1000 === 0 && progress) {\n      progress(\"compact:nodes\", index, forks.length);\n    }\n\n    return result;\n  }\n}\n\nexport function compactNode<TEdgeData, TProperties>(\n  key: Key,\n  vertices: Vertices,\n  ends: Vertices,\n  vertexCoords: Coordinates,\n  edgeData: Record<Key, Record<Key, TEdgeData | undefined>>,\n  trackIncoming: boolean,\n  options: PathFinderOptions<TEdgeData, TProperties> = {}\n) {\n  const neighbors = vertices[key];\n  return Object.keys(neighbors).reduce(compactEdge, {\n    edges: {},\n    incomingEdges: {},\n    coordinates: {},\n    incomingCoordinates: {},\n    reducedEdges: {},\n  });\n\n  function compactEdge(\n    result: {\n      edges: Record<Key, number>;\n      incomingEdges: Record<Key, number>;\n      coordinates: Record<Key, Position[]>;\n      incomingCoordinates: Record<Key, Position[]>;\n      reducedEdges: Record<Key, TEdgeData | undefined>;\n    },\n    j: Key\n  ) {\n    const neighbor = findNextFork(\n      key,\n      j,\n      vertices,\n      ends,\n      vertexCoords,\n      edgeData,\n      trackIncoming,\n      options\n    );\n    const weight = neighbor.weight;\n    const reverseWeight = neighbor.reverseWeight;\n    if (neighbor.vertexKey !== key) {\n      if (\n        !result.edges[neighbor.vertexKey] ||\n        result.edges[neighbor.vertexKey] > weight\n      ) {\n        result.edges[neighbor.vertexKey] = weight;\n        result.coordinates[neighbor.vertexKey] = [vertexCoords[key]].concat(\n          neighbor.coordinates\n        );\n        result.reducedEdges[neighbor.vertexKey] = neighbor.reducedEdge;\n      }\n      if (\n        trackIncoming &&\n        !isNaN(reverseWeight) &&\n        (!result.incomingEdges[neighbor.vertexKey] ||\n          result.incomingEdges[neighbor.vertexKey] > reverseWeight)\n      ) {\n        result.incomingEdges[neighbor.vertexKey] = reverseWeight;\n        var coordinates = [vertexCoords[key]].concat(neighbor.coordinates);\n        coordinates.reverse();\n        result.incomingCoordinates[neighbor.vertexKey] = coordinates;\n      }\n    }\n    return result;\n  }\n}\n\nfunction findNextFork<TEdgeData, TProperties>(\n  prev: Key,\n  vertexKey: Key,\n  vertices: Vertices,\n  ends: Vertices,\n  vertexCoords: Coordinates,\n  edgeData: Record<Key, Record<Key, TEdgeData | undefined>>,\n  trackIncoming: boolean,\n  options: PathFinderOptions<TEdgeData, TProperties> = {}\n) {\n  let weight = vertices[prev][vertexKey];\n  let reverseWeight = vertices[vertexKey][prev];\n  const coordinates = [];\n  const path = [];\n  let reducedEdge =\n    \"edgeDataReducer\" in options ? edgeData[vertexKey][prev] : undefined;\n\n  while (!ends[vertexKey]) {\n    var edges = vertices[vertexKey];\n\n    if (!edges) {\n      break;\n    }\n\n    var next = Object.keys(edges).filter(function notPrevious(k) {\n      return k !== prev;\n    })[0];\n    weight += edges[next];\n\n    if (trackIncoming) {\n      reverseWeight += vertices[next][vertexKey];\n\n      if (path.indexOf(vertexKey) >= 0) {\n        ends[vertexKey] = vertices[vertexKey];\n        break;\n      }\n      path.push(vertexKey);\n    }\n\n    const nextEdgeData = edgeData[vertexKey] && edgeData[vertexKey][next];\n    if (\"edgeDataReducer\" in options && reducedEdge && nextEdgeData) {\n      reducedEdge = options.edgeDataReducer(reducedEdge, nextEdgeData);\n    }\n\n    coordinates.push(vertexCoords[vertexKey]);\n    prev = vertexKey;\n    vertexKey = next;\n  }\n\n  return {\n    vertexKey,\n    weight: weight,\n    reverseWeight: reverseWeight,\n    coordinates: coordinates,\n    reducedEdge: reducedEdge,\n  };\n}\n"],"mappings":"AAGA;;;;;;;;;;;;;;;;;AAiBA,eAAc,SAAUA,YAAYA,CAClCC,QAAkB,EAClBC,YAAyB,EACzBC,QAAyD,EACF;EAAA,IAAvDC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAqD,EAAE;EAEvD,MAAM;IAAEG,QAAQ;IAAEC,OAAO,GAAG;EAAI,CAAE,GAAGL,OAAO;EAC5C,MAAMM,IAAI,GAAGC,MAAM,CAACC,IAAI,CAACX,QAAQ,CAAC,CAACY,MAAM,CAACC,SAAS,EAAE,EAAE,CAAC;EAExD,OAAOH,MAAM,CAACC,IAAI,CAACF,IAAI,CAAC,CAACG,MAAM,CAACE,WAAW,EAAE;IAC3CC,KAAK,EAAE,EAAE;IACTC,WAAW,EAAE,EAAE;IACfC,YAAY,EAAE;GACf,CAAC;EAEF,SAASJ,SAASA,CAChBJ,IAAc,EACdS,GAAQ,EACRC,KAAa,EACbC,UAAiB;IAEjB,MAAMC,MAAM,GAAGrB,QAAQ,CAACkB,GAAG,CAAC;IAC5B,MAAMI,KAAK,GAAGZ,MAAM,CAACC,IAAI,CAACU,MAAM,CAAC;IACjC,MAAME,WAAW,GAAGD,KAAK,CAACjB,MAAM;IAChC,IAAImB,KAAK;IAET,IAAI,CAAChB,OAAO,EAAE;MACZ;MACA;MACAgB,KAAK,GAAG,IAAI;KACb,MAAM,IAAID,WAAW,KAAK,CAAC,EAAE;MAC5B;MACA;MACA;MACA,MAAME,KAAK,GAAGzB,QAAQ,CAACsB,KAAK,CAAC,CAAC,CAAC,CAAC;MAChCE,KAAK,GAAGC,KAAK,CAACP,GAAG,CAAC;KACnB,MAAM,IAAIK,WAAW,KAAK,CAAC,EAAE;MAC5B;MACA;MACAC,KAAK,GAAGF,KAAK,CAACI,IAAI,CAAEC,CAAC,IAAK,CAAC3B,QAAQ,CAAC2B,CAAC,CAAC,CAACT,GAAG,CAAC,CAAC;KAC7C,MAAM;MACL;MACAM,KAAK,GAAG,IAAI;;IAGd,IAAIA,KAAK,EAAE;MACTf,IAAI,CAACS,GAAG,CAAC,GAAGG,MAAM;;IAGpB,IAAIF,KAAK,GAAG,IAAI,KAAK,CAAC,IAAIZ,QAAQ,EAAE;MAClCA,QAAQ,CAAC,cAAc,EAAEY,KAAK,EAAEC,UAAU,CAACf,MAAM,CAAC;;IAGpD,OAAOI,IAAI;EACb;EAEA,SAASK,WAAWA,CAClBc,MAIC,EACDV,GAAQ,EACRC,KAAa,EACbU,KAAY;IAEZ,IAAIC,SAAS,GAAGC,WAAW,CACzBb,GAAG,EACHlB,QAAQ,EACRS,IAAI,EACJR,YAAY,EACZC,QAAQ,EACR,KAAK,EACLC,OAAO,CACR;IACDyB,MAAM,CAACb,KAAK,CAACG,GAAG,CAAC,GAAGY,SAAS,CAACR,KAAK;IACnCM,MAAM,CAACZ,WAAW,CAACE,GAAG,CAAC,GAAGY,SAAS,CAACd,WAAW;IAC/CY,MAAM,CAACX,YAAY,CAACC,GAAG,CAAC,GAAGY,SAAS,CAACb,YAAY;IAEjD,IAAIE,KAAK,GAAG,IAAI,KAAK,CAAC,IAAIZ,QAAQ,EAAE;MAClCA,QAAQ,CAAC,eAAe,EAAEY,KAAK,EAAEU,KAAK,CAACxB,MAAM,CAAC;;IAGhD,OAAOuB,MAAM;EACf;AACF;AAEA,OAAM,SAAUG,WAAWA,CACzBb,GAAQ,EACRlB,QAAkB,EAClBS,IAAc,EACdR,YAAyB,EACzBC,QAAyD,EACzD8B,aAAsB,EACiC;EAAA,IAAvD7B,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAqD,EAAE;EAEvD,MAAM6B,SAAS,GAAGjC,QAAQ,CAACkB,GAAG,CAAC;EAC/B,OAAOR,MAAM,CAACC,IAAI,CAACsB,SAAS,CAAC,CAACrB,MAAM,CAACsB,WAAW,EAAE;IAChDZ,KAAK,EAAE,EAAE;IACTa,aAAa,EAAE,EAAE;IACjBnB,WAAW,EAAE,EAAE;IACfoB,mBAAmB,EAAE,EAAE;IACvBnB,YAAY,EAAE;GACf,CAAC;EAEF,SAASiB,WAAWA,CAClBN,MAMC,EACDS,CAAM;IAEN,MAAMC,QAAQ,GAAGC,YAAY,CAC3BrB,GAAG,EACHmB,CAAC,EACDrC,QAAQ,EACRS,IAAI,EACJR,YAAY,EACZC,QAAQ,EACR8B,aAAa,EACb7B,OAAO,CACR;IACD,MAAMqC,MAAM,GAAGF,QAAQ,CAACE,MAAM;IAC9B,MAAMC,aAAa,GAAGH,QAAQ,CAACG,aAAa;IAC5C,IAAIH,QAAQ,CAACI,SAAS,KAAKxB,GAAG,EAAE;MAC9B,IACE,CAACU,MAAM,CAACN,KAAK,CAACgB,QAAQ,CAACI,SAAS,CAAC,IACjCd,MAAM,CAACN,KAAK,CAACgB,QAAQ,CAACI,SAAS,CAAC,GAAGF,MAAM,EACzC;QACAZ,MAAM,CAACN,KAAK,CAACgB,QAAQ,CAACI,SAAS,CAAC,GAAGF,MAAM;QACzCZ,MAAM,CAACZ,WAAW,CAACsB,QAAQ,CAACI,SAAS,CAAC,GAAG,CAACzC,YAAY,CAACiB,GAAG,CAAC,CAAC,CAACyB,MAAM,CACjEL,QAAQ,CAACtB,WAAW,CACrB;QACDY,MAAM,CAACX,YAAY,CAACqB,QAAQ,CAACI,SAAS,CAAC,GAAGJ,QAAQ,CAACM,WAAW;;MAEhE,IACEZ,aAAa,IACb,CAACa,KAAK,CAACJ,aAAa,CAAC,KACpB,CAACb,MAAM,CAACO,aAAa,CAACG,QAAQ,CAACI,SAAS,CAAC,IACxCd,MAAM,CAACO,aAAa,CAACG,QAAQ,CAACI,SAAS,CAAC,GAAGD,aAAa,CAAC,EAC3D;QACAb,MAAM,CAACO,aAAa,CAACG,QAAQ,CAACI,SAAS,CAAC,GAAGD,aAAa;QACxD,IAAIzB,WAAW,GAAG,CAACf,YAAY,CAACiB,GAAG,CAAC,CAAC,CAACyB,MAAM,CAACL,QAAQ,CAACtB,WAAW,CAAC;QAClEA,WAAW,CAAC8B,OAAO,EAAE;QACrBlB,MAAM,CAACQ,mBAAmB,CAACE,QAAQ,CAACI,SAAS,CAAC,GAAG1B,WAAW;;;IAGhE,OAAOY,MAAM;EACf;AACF;AAEA,SAASW,YAAYA,CACnBQ,IAAS,EACTL,SAAc,EACd1C,QAAkB,EAClBS,IAAc,EACdR,YAAyB,EACzBC,QAAyD,EACzD8B,aAAsB,EACiC;EAAA,IAAvD7B,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAqD,EAAE;EAEvD,IAAIoC,MAAM,GAAGxC,QAAQ,CAAC+C,IAAI,CAAC,CAACL,SAAS,CAAC;EACtC,IAAID,aAAa,GAAGzC,QAAQ,CAAC0C,SAAS,CAAC,CAACK,IAAI,CAAC;EAC7C,MAAM/B,WAAW,GAAG,EAAE;EACtB,MAAMgC,IAAI,GAAG,EAAE;EACf,IAAIJ,WAAW,GACb,iBAAiB,IAAIzC,OAAO,GAAGD,QAAQ,CAACwC,SAAS,CAAC,CAACK,IAAI,CAAC,GAAGzC,SAAS;EAEtE,OAAO,CAACG,IAAI,CAACiC,SAAS,CAAC,EAAE;IACvB,IAAIpB,KAAK,GAAGtB,QAAQ,CAAC0C,SAAS,CAAC;IAE/B,IAAI,CAACpB,KAAK,EAAE;MACV;;IAGF,IAAI2B,IAAI,GAAGvC,MAAM,CAACC,IAAI,CAACW,KAAK,CAAC,CAAC4B,MAAM,CAAC,SAASC,WAAWA,CAACC,CAAC;MACzD,OAAOA,CAAC,KAAKL,IAAI;IACnB,CAAC,CAAC,CAAC,CAAC,CAAC;IACLP,MAAM,IAAIlB,KAAK,CAAC2B,IAAI,CAAC;IAErB,IAAIjB,aAAa,EAAE;MACjBS,aAAa,IAAIzC,QAAQ,CAACiD,IAAI,CAAC,CAACP,SAAS,CAAC;MAE1C,IAAIM,IAAI,CAACK,OAAO,CAACX,SAAS,CAAC,IAAI,CAAC,EAAE;QAChCjC,IAAI,CAACiC,SAAS,CAAC,GAAG1C,QAAQ,CAAC0C,SAAS,CAAC;QACrC;;MAEFM,IAAI,CAACM,IAAI,CAACZ,SAAS,CAAC;;IAGtB,MAAMa,YAAY,GAAGrD,QAAQ,CAACwC,SAAS,CAAC,IAAIxC,QAAQ,CAACwC,SAAS,CAAC,CAACO,IAAI,CAAC;IACrE,IAAI,iBAAiB,IAAI9C,OAAO,IAAIyC,WAAW,IAAIW,YAAY,EAAE;MAC/DX,WAAW,GAAGzC,OAAO,CAACqD,eAAe,CAACZ,WAAW,EAAEW,YAAY,CAAC;;IAGlEvC,WAAW,CAACsC,IAAI,CAACrD,YAAY,CAACyC,SAAS,CAAC,CAAC;IACzCK,IAAI,GAAGL,SAAS;IAChBA,SAAS,GAAGO,IAAI;;EAGlB,OAAO;IACLP,SAAS;IACTF,MAAM,EAAEA,MAAM;IACdC,aAAa,EAAEA,aAAa;IAC5BzB,WAAW,EAAEA,WAAW;IACxB4B,WAAW,EAAEA;GACd;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}