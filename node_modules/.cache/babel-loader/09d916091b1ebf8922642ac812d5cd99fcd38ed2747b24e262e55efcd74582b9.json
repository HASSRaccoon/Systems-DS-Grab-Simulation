{"ast":null,"code":"import Queue from \"tinyqueue\";\nexport default function findPath(graph, start, end) {\n  const costs = {\n    [start]: 0\n  };\n  const initialState = [0, [start], start];\n  const queue = new Queue([initialState], (a, b) => a[0] - b[0]);\n  while (true) {\n    const state = queue.pop();\n    if (!state) {\n      return undefined;\n    }\n    const cost = state[0];\n    const node = state[2];\n    if (node === end) {\n      return [state[0], state[1]];\n    }\n    const neighbours = graph[node];\n    Object.keys(neighbours).forEach(function (n) {\n      var newCost = cost + neighbours[n];\n      if (!(n in costs) || newCost < costs[n]) {\n        costs[n] = newCost;\n        const newState = [newCost, state[1].concat([n]), n];\n        queue.push(newState);\n      }\n    });\n  }\n}","map":{"version":3,"names":["Queue","findPath","graph","start","end","costs","initialState","queue","a","b","state","pop","undefined","cost","node","neighbours","Object","keys","forEach","n","newCost","newState","concat","push"],"sources":["/Users/valu/Desktop/TESTSDS/Systems-DS-Grab-Simulation/node_modules/geojson-path-finder/src/dijkstra.ts"],"sourcesContent":["import Queue from \"tinyqueue\";\nimport { Key, Vertices } from \"./types\";\n\ntype State = [number, Key[], Key];\n\nexport default function findPath(\n  graph: Vertices,\n  start: Key,\n  end: Key\n): [number, Key[]] | undefined {\n  const costs: Record<Key, number> = { [start]: 0 };\n  const initialState: State = [0, [start], start];\n  const queue = new Queue([initialState], (a: State, b: State) => a[0] - b[0]);\n\n  while (true) {\n    const state = queue.pop();\n    if (!state) {\n      return undefined;\n    }\n\n    const cost = state[0];\n    const node = state[2];\n    if (node === end) {\n      return [state[0], state[1]];\n    }\n\n    const neighbours = graph[node];\n    Object.keys(neighbours).forEach(function (n) {\n      var newCost = cost + neighbours[n];\n      if (!(n in costs) || newCost < costs[n]) {\n        costs[n] = newCost;\n        const newState: State = [newCost, state[1].concat([n]), n];\n        queue.push(newState);\n      }\n    });\n  }\n}\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,WAAW;AAK7B,eAAc,SAAUC,QAAQA,CAC9BC,KAAe,EACfC,KAAU,EACVC,GAAQ;EAER,MAAMC,KAAK,GAAwB;IAAE,CAACF,KAAK,GAAG;EAAC,CAAE;EACjD,MAAMG,YAAY,GAAU,CAAC,CAAC,EAAE,CAACH,KAAK,CAAC,EAAEA,KAAK,CAAC;EAC/C,MAAMI,KAAK,GAAG,IAAIP,KAAK,CAAC,CAACM,YAAY,CAAC,EAAE,CAACE,CAAQ,EAAEC,CAAQ,KAAKD,CAAC,CAAC,CAAC,CAAC,GAAGC,CAAC,CAAC,CAAC,CAAC,CAAC;EAE5E,OAAO,IAAI,EAAE;IACX,MAAMC,KAAK,GAAGH,KAAK,CAACI,GAAG,EAAE;IACzB,IAAI,CAACD,KAAK,EAAE;MACV,OAAOE,SAAS;;IAGlB,MAAMC,IAAI,GAAGH,KAAK,CAAC,CAAC,CAAC;IACrB,MAAMI,IAAI,GAAGJ,KAAK,CAAC,CAAC,CAAC;IACrB,IAAII,IAAI,KAAKV,GAAG,EAAE;MAChB,OAAO,CAACM,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;;IAG7B,MAAMK,UAAU,GAAGb,KAAK,CAACY,IAAI,CAAC;IAC9BE,MAAM,CAACC,IAAI,CAACF,UAAU,CAAC,CAACG,OAAO,CAAC,UAAUC,CAAC;MACzC,IAAIC,OAAO,GAAGP,IAAI,GAAGE,UAAU,CAACI,CAAC,CAAC;MAClC,IAAI,EAAEA,CAAC,IAAId,KAAK,CAAC,IAAIe,OAAO,GAAGf,KAAK,CAACc,CAAC,CAAC,EAAE;QACvCd,KAAK,CAACc,CAAC,CAAC,GAAGC,OAAO;QAClB,MAAMC,QAAQ,GAAU,CAACD,OAAO,EAAEV,KAAK,CAAC,CAAC,CAAC,CAACY,MAAM,CAAC,CAACH,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC;QAC1DZ,KAAK,CAACgB,IAAI,CAACF,QAAQ,CAAC;;IAExB,CAAC,CAAC;;AAEN"},"metadata":{},"sourceType":"module","externalDependencies":[]}